# ch6 算法横向拆分，分离步骤

## 1. 接口的分离

对两种不同层面的变化，应该有所区分：

- 在实现层面上：对于每个功能，存在多种实现方法

    相对于基类是可变的，每种变化对应于一个派生类。这种变化表现在编译期，是一种相对静态的可变。

- 在组织层面上：“大类” 的功能由一系列子功能构成

    子功能之间是相互独立的，应当将这些子功能拆分到不同的 “小类”，组合是自由的、动态的、可变的，通过实现子功能的 “小类” 对象的组合来完成。这种变化表现在运行期，是一种更加动态的可变。

简单来说，我们需要隔离不同层面的变化：静态的可变用继承，动态的可变用组合。

## 2. 单一责任原则

类的功能应该是内聚的，一个类只承担一项功能。表现为：修改 / 派生一个类之应该有一个理由，只能够由单个变化因素引起。

将多个不同的功能交由同一个类实现，违反了单一责任原则，当一个功能需要变化时，不得不修改或者派生新的实现类。

## 3. 分离接口的方法

策略模式：剥离出新的接口，每个功能（算法）的实现定义为一个接口（称为**策略**），与接口的不同实现组合成一个策略类的体系。用组合替代继承，用功能接口之间的组合来实现功能之间的组合。

委托模式：自身并不实现相应功能，将具体实现委托给其他功能。

$\tt Bridge$ 模式：把抽象部分与实现部分分离，使它们都可以独立变化。